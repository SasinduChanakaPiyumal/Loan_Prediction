#!/usr/bin/env python
# coding: utf-8
"""
Security vulnerability fix test suite.

This test module demonstrates that the path traversal vulnerability in the 
original Loan_Data_1.py has been fixed. The vulnerability allowed:
- Access to arbitrary files using absolute paths
- Exposure of machine-specific filesystem structure
- Potential unauthorized file access

The fix implements:
- Relative path usage from the script directory
- Path traversal attack detection
- Absolute path rejection
- Existence validation

Tests verify that these security controls work correctly.
"""

import unittest
import sys
import os
from pathlib import Path
import tempfile
import shutil

# Add the current directory to the path so we can import Loan_Data_1
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Import the fixed function
from Loan_Data_1 import load_loan_data


class TestSecurityVulnerabilityFix(unittest.TestCase):
    """Test cases for the path traversal vulnerability fix."""
    
    def setUp(self):
        """Set up test fixtures."""
        self.temp_dir = tempfile.mkdtemp()
        self.original_dir = os.getcwd()
        os.chdir(self.temp_dir)
        
    def tearDown(self):
        """Clean up test fixtures."""
        os.chdir(self.original_dir)
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_01_reject_absolute_windows_path(self):
        """
        Test 1: Absolute Windows paths are rejected.
        
        VULNERABILITY SCENARIO: The original code used absolute Windows path.
        This test verifies the fix prevents loading from absolute paths.
        EXPLOIT: An attacker could modify the path to access sensitive files
        like 'C:\\Windows\\System32\\drivers\\etc\\hosts' or user data.
        """
        print("\n--- Test 1: Reject absolute Windows paths ---")
        with self.assertRaises(ValueError) as context:
            load_loan_data('Z:\\Sasindu\\Data set\\loan_data_set.csv')
        
        self.assertIn("Invalid filename", str(context.exception))
        print(f"✓ PASS: Absolute path rejected with error: {context.exception}")
    
    def test_02_reject_absolute_unix_path(self):
        """
        Test 2: Absolute Unix/Linux paths are rejected.
        
        VULNERABILITY SCENARIO: On Linux/Mac systems, attackers could use /etc/passwd
        EXPLOIT: An attacker could read sensitive system files.
        """
        print("\n--- Test 2: Reject absolute Unix paths ---")
        with self.assertRaises(ValueError) as context:
            load_loan_data('/etc/passwd')
        
        self.assertIn("Invalid filename", str(context.exception))
        print(f"✓ PASS: Unix absolute path rejected with error: {context.exception}")
    
    def test_03_reject_parent_directory_traversal(self):
        """
        Test 3: Parent directory traversal attempts are rejected.
        
        VULNERABILITY SCENARIO: ../../../etc/passwd style attacks
        EXPLOIT: An attacker could escape the application directory and access files outside it.
        """
        print("\n--- Test 3: Reject parent directory traversal (../) ---")
        with self.assertRaises(ValueError) as context:
            load_loan_data('../../../etc/passwd')
        
        self.assertIn("Invalid filename", str(context.exception))
        print(f"✓ PASS: Path traversal rejected with error: {context.exception}")
    
    def test_04_reject_windows_parent_traversal(self):
        """
        Test 4: Windows-style parent directory traversal is rejected.
        
        VULNERABILITY SCENARIO: ..\\..\\..\\Windows\\System32\\drivers\\etc\\hosts
        EXPLOIT: Escape application directory on Windows systems.
        """
        print("\n--- Test 4: Reject Windows parent directory traversal (..\) ---")
        with self.assertRaises(ValueError) as context:
            load_loan_data('..\\..\\..\\sensitive_data.txt')
        
        self.assertIn("Invalid filename", str(context.exception))
        print(f"✓ PASS: Windows path traversal rejected with error: {context.exception}")
    
    def test_05_reject_nonexistent_file(self):
        """
        Test 5: Nonexistent files are properly rejected.
        
        This ensures files must exist before being loaded.
        """
        print("\n--- Test 5: Reject nonexistent files ---")
        with self.assertRaises(FileNotFoundError) as context:
            load_loan_data('nonexistent_file.csv')
        
        self.assertIn("not found", str(context.exception))
        print(f"✓ PASS: Nonexistent file rejected with error: {context.exception}")
    
    def test_06_accept_valid_relative_path(self):
        """
        Test 6: Valid relative paths with actual files are accepted.
        
        This is the positive test case showing the fix allows legitimate use.
        """
        print("\n--- Test 6: Accept valid relative paths ---")
        
        # Create a temporary CSV file in the temp directory
        test_csv_content = """Loan_ID,Gender,Married,Loan_Status
LP001,Male,Yes,Y
LP002,Female,No,N"""
        
        csv_file = os.path.join(self.temp_dir, 'test_loan_data.csv')
        with open(csv_file, 'w') as f:
            f.write(test_csv_content)
        
        try:
            df = load_loan_data('test_loan_data.csv')
            self.assertIsNotNone(df)
            self.assertEqual(len(df), 2)
            print(f"✓ PASS: Valid relative path accepted and loaded {len(df)} rows")
        except Exception as e:
            self.fail(f"Valid relative path should be accepted. Error: {e}")
    
    def test_07_detect_symlink_escapes(self):
        """
        Test 7: Symbolic link based directory escape attempts are prevented.
        
        VULNERABILITY SCENARIO: A symlink could bypass directory restrictions
        EXPLOIT: Create symlink to point outside the application directory.
        """
        print("\n--- Test 7: Detect symlink-based escapes ---")
        
        # Create a directory outside temp_dir
        outside_dir = tempfile.mkdtemp()
        sensitive_file = os.path.join(outside_dir, 'sensitive.csv')
        
        try:
            # Create a sensitive file outside the app directory
            with open(sensitive_file, 'w') as f:
                f.write("sensitive_data")
            
            # Create a symlink inside the app directory pointing to the outside file
            symlink_path = os.path.join(self.temp_dir, 'link_to_outside.csv')
            
            # Try to create symlink (may not work on all systems)
            try:
                os.symlink(sensitive_file, symlink_path)
                
                # The load_loan_data should detect this as path traversal
                with self.assertRaises(ValueError) as context:
                    load_loan_data('link_to_outside.csv')
                
                self.assertIn("Path traversal", str(context.exception))
                print(f"✓ PASS: Symlink escape detected with error: {context.exception}")
            except (OSError, NotImplementedError):
                # Symlinks might not be supported on all systems (e.g., Windows)
                print(f"⊘ SKIP: Symlinks not supported on this system")
                
        finally:
            shutil.rmtree(outside_dir, ignore_errors=True)
    
    def test_08_original_vulnerability_blocked(self):
        """
        Test 8: The ORIGINAL VULNERABILITY is blocked.
        
        This is the main test demonstrating the fix works.
        Original vulnerability: df = pd.read_csv('Z:\\Sasindu\\Data set\\loan_data_set.csv')
        
        This could have been exploited by changing the path to:
        - 'C:\\Windows\\System32\\config\\SAM' (Windows credentials)
        - '/etc/shadow' (Linux passwords)
        - Any other sensitive file on the system
        """
        print("\n--- Test 8: Original vulnerability is blocked ---")
        print("Original code: df = pd.read_csv('Z:\\\\Sasindu\\\\Data set\\\\loan_data_set.csv')")
        print("Potential exploits that would have worked:")
        print("  - Change to 'C:\\\\Windows\\\\System32\\\\config\\\\SAM' for credentials")
        print("  - Change to '/etc/shadow' for system passwords")
        print("  - Change to any other sensitive file")
        print()
        
        # Verify all exploit scenarios are blocked
        exploit_paths = [
            'Z:\\Sasindu\\Data set\\loan_data_set.csv',  # Original
            'C:\\Windows\\System32\\config\\SAM',         # Windows credentials
            '/etc/shadow',                                  # Linux passwords
            '/etc/passwd',                                  # User information
            '../../../etc/passwd',                          # Directory escape
            '..\\..\\..\\sensitive_data.txt',             # Windows escape
        ]
        
        blocked_count = 0
        for path in exploit_paths:
            try:
                load_loan_data(path)
                print(f"✗ FAIL: Path {path} was not blocked!")
            except (ValueError, FileNotFoundError):
                blocked_count += 1
        
        self.assertEqual(blocked_count, len(exploit_paths), 
                        f"Not all exploit paths were blocked. {blocked_count}/{len(exploit_paths)} blocked")
        print(f"✓ PASS: All {blocked_count} exploit paths are blocked")


class TestVulnerabilityDocumentation(unittest.TestCase):
    """Test that documentation of the vulnerability and fix is present."""
    
    def test_vulnerability_documented_in_source(self):
        """Verify the vulnerability and fix are documented in the source code."""
        print("\n--- Test: Vulnerability documented in source ---")
        
        with open('Loan_Data_1.py', 'r') as f:
            content = f.read()
        
        # Check for security documentation
        self.assertIn("SECURITY FIX", content)
        self.assertIn("path traversal", content.lower())
        self.assertIn("load_loan_data", content)
        
        print("✓ PASS: Security documentation found in source code")


if __name__ == '__main__':
    print("=" * 80)
    print("SECURITY VULNERABILITY FIX TEST SUITE")
    print("=" * 80)
    print("\nVulnerability: Path Traversal & Information Disclosure")
    print("CVE Type: CWE-22 (Improper Limitation of a Pathname to a Restricted Directory)")
    print("\nOriginal vulnerable code:")
    print("  df = pd.read_csv('Z:\\\\Sasindu\\\\Data set\\\\loan_data_set.csv')")
    print("\nIssues:")
    print("  1. Exposes user's filesystem structure")
    print("  2. Machine-specific hardcoded paths")
    print("  3. Could be exploited for arbitrary file access")
    print("  4. Violates principle of least privilege")
    print("\n" + "=" * 80)
    
    unittest.main(verbosity=2)
